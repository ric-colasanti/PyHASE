<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Latest compiled and minified CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css"
    />

    <title>Template</title>
  </head>

  <body>
    <div class="container" style="margin-top: 80px">
      <svg
        id="svg01"
        width="500"
        height="500"
        style="border-style: solid"
      ></svg>
    </div>

    <!-- Latest compiled JavaScript -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      let population = [];
      var frame = document.getElementById("svg01");
      let shoppedOut = false;

      function getAngleDegrees(fromX, fromY, toX, toY, force360 = true) {
        let deltaX = fromX - toX;
        let deltaY = fromY - toY; // reverse
        let radians = Math.atan2(deltaY, deltaX);
        let degrees = (radians * 180) / Math.PI - 90; // rotate
        if (force360) {
          while (degrees >= 360) degrees -= 360;
          while (degrees < 0) degrees += 360;
        }
        return degrees;
      }

      function rndInt(maxVal) {
        return Math.floor(Math.random() * maxVal);
      }

      class Pos {
        constructor(xPos, yPos) {
          this.xPos = xPos;
          this.yPos = yPos;
        }

        move(dx, dy) {
          this.xPos += dx;
          this.yPos += dy;
        }

        dx(point) {
          return this.xPos - point.xPos;
        }
        dy(point) {
          return this.yPos - point.yPos;
        }
      }

      class Person {
        constructor(pos) {
          this.shape = SVG("polygon");
          this.shape.setAttribute("fill", "red");
          this.shape.setAttribute("stroke", "black");
          let array = [
            [0, -10],
            [10, 10],
            [0, 5],
            [-10, 10],
          ];
          for (let value of array) {
            let point = frame.createSVGPoint();
            point.x = value[0];
            point.y = value[1];
            this.shape.points.appendItem(point);
          }
          this.home = new Pos(pos.xPos, pos.yPos);
          this.pos = pos;
          this.target = null;
          this.shop = null;
          this.deg = 0;
          this.atHome = false;
          this.shoped = false;
        }

        setTarget(target) {
          this.target = new Pos(target.xPos, target.yPos);
          let dx = target.dx(this.pos);
          let dy = target.dy(this.pos);
          this.dx = (dx / Math.sqrt(dx * dx + dy * dy)) * 6;
          this.dy = (dy / Math.sqrt(dx * dx + dy * dy)) * 6;

          this.deg = getAngleDegrees(
            this.pos.xPos,
            this.pos.yPos,
            this.target.xPos,
            this.target.yPos,
            false
          );
        }

        distance(xPos, yPos) {
          let dx = Math.abs(this.pos.xPos - xPos);
          let dy = Math.abs(this.pos.yPos - yPos);
          if (dy > size / 2) {
            dy = size - dy;
          }
          if (dx > size / 2) {
            dx = size - dx;
          }
          return Math.sqrt(dx * dx + dy * dy);
        }

        draw() {
          this.shape.setAttribute("fill", "red");
          this.shape.setAttribute(
            "transform",

            "translate(" +
              this.pos.xPos +
              "," +
              this.pos.yPos +
              ") rotate(" +
              this.deg +
              " " +
              0 +
              " " +
              0 +
              " ) scale(0.5,0.5)"
          );
        }
        drawHome() {
          this.shape.setAttribute("fill", "orange");
          this.shape.setAttribute(
            "transform",

            "translate(" +
              this.home.xPos +
              "," +
              this.home.yPos +
              ") rotate(" +
              0 +
              " " +
              0 +
              " " +
              0 +
              " ) scale(0.5,0.5)"
          );
        }
        move() {
          if (
            Math.abs(this.pos.xPos - this.target.xPos) > 4 &&
            Math.abs(this.pos.yPos - this.target.yPos) > 4
          ) {
            this.pos.move(this.dx, this.dy);
            this.draw();
          } else {
            if (this.atHome) {
              this.pos.xPos = this.home.xPos;
              this.pos.yPos = this.home.yPos;
              this.drawHome();
              if (this.shoped == false) {
                this.shoped = true;
              }
            } else {
              this.pos.xPos = this.shop.xPos;
              this.pos.yPos = this.shop.yPos;
              this.setTarget(this.home);
              this.atHome = true;
              this.draw();
            }
          }
        }
      }

      function SVG(elementName) {
        return document.createElementNS(
          "http://www.w3.org/2000/svg",
          elementName
        );
      }

      function setup() {
        shops = [];
        for (let i = 0; i < 50; i++) {
          shops.push(new Pos(rndInt(50) * 10, rndInt(50) * 10));
        }
        for (let x = 1; x < 49; x++) {
          for (let y = 1; y < 49; y++) {
            const person = new Person(new Pos(x * 10, y * 10));
            person.shop = shops[rndInt(shops.length)];
            person.setTarget(person.shop);
            population.push(person);
            frame.appendChild(person.shape);
          }
        }
      }

      update = function () {
        shoppedOut = true;
        let count = 0;
        for (let i = 0; i < population.length; i++) {
          population[i].move();
          if (population[i].shoped == false) {
            shoppedOut = false;
            count++;
          }
        }
        if (shoppedOut == true) {
          for (let i = 0; i < population.length; i++) {
            population[i].shoped = false;
            population[i].setTarget(population[i].shop);
          }
        }

        setTimeout(function () {
          window.requestAnimationFrame(update);
        }, 1);
      };

      setup();
      update();
    </script>
  </body>
</html>
